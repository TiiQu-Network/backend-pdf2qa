service: pdf2qa-validation-api
frameworkVersion: "3"
useDotenv: true

plugins:
  - serverless-better-credentials
  - serverless-offline
  - serverless-esbuild
  - serverless-plugin-test-helper
  - serverless-s3-local
  - serverless-step-functions
  - serverless-step-functions-offline
  - serverless-secrets-plugin

package:
  patterns:
    - "!node_modules/**"
    - "!src/**"
    - "!terraform/**"

provider:
  name: aws
  runtime: nodejs18.x
  stage: ${opt:stage, 'dev'}
  profile: ardavan1@hotmail.co.uk
  region: eu-west-2

custom:
  stage: ${opt:stage, 'dev'}
  serverless-offline:
    httpPort: 4000
  dotenv:
    dotenv_path: .env.${opt:stage, 'dev'}
  s3:
    host: localhost
    directory: ./.buckets
    cors: ./s3-cors.xml
    allowMismatchedSignatures: true
  stepFunctionsOffline:
    stateMachineName: pdfValidationStateMachine
  esbuild:
    exclude: []
  holdingAreaBucketName: ${self:custom.stage}-${self:service}-holding-area-bucket
  validatedFilesBucketName: ${self:custom.stage}-${self:service}-validated-files-bucket
  secrets:
    file: secrets.${opt:stage}.yml

resources:
  Resources:
    HoldingAreaBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:custom.holdingAreaBucketName}
        PublicAccessBlockConfiguration:
          # allows S3BucketPolicy to be applied via deployment
          BlockPublicPolicy: false
          # allows public access to the bucket but within the restrictions of the S3BucketPolicy
          RestrictPublicBuckets: false
        CorsConfiguration:
          # allow PUT requests from our local dev environments
          CorsRules:
            - AllowedOrigins:
                # add development origin (i.e. our Vercel hosting origin)
                - 'http://localhost:3000'
              AllowedHeaders:
                - '*'
              AllowedMethods:
                - PUT
              MaxAge: 3000
        BucketEncryption:
          ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256

    S3BucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket:
          Ref: HoldingAreaBucket
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                AWS: "*" # Allow all AWS services
              Action:
                - s3:GetObject
                - s3:PutObject
              Resource:
                Fn::Sub:
                  - arn:aws:s3:::${BucketName}/*
                  - BucketName:
                      Ref: HoldingAreaBucket

    ValidatedFilesBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:custom.validatedFilesBucketName}
  Outputs:
    PdfValidationStateMachineArn:
      Description: The ARN of the PDF Validation State Machine
      Value:
        Ref: PdfValidationStateMachine

functions:
  authorizer:
    handler: ./src/lambda/authorizer.handler
    name: authorizer
    environment:
      AUTH0_DOMAIN: ${env.AUTH0_DOMAIN}
      API_IDENTIFIER: ${env.API_IDENTIFIER}
      API_SECRET: ${env.API_SECRET}
    events:
      - http:
          path: /authorizer
          method: post
  generatePresignedUrl:
    handler: ./src/lambda/generatePresignedUrl.handler
    events:
      - http:
          path: /generate-presigned-url
          method: post
          # cors: true
          authorizer:
            name: authorizer
            resultTtlInSeconds: 0
            identitySource: method.request.header.Authorization
            type: token
    environment:
      HOLDING_AREA_BUCKET_NAME: ${self:resources.Resources.HoldingAreaBucket.Properties.BucketName}
  triggerPdfValidation:
    handler: ./src/lambda/triggerPdfValidation.handler
    events:
      - s3:
          bucket: ${self:custom.holdingAreaBucketName}
          event: s3:ObjectCreated:*
          existing: true
    environment:
      PDF_VALIDATION_STATE_MACHINE_ARN: ${self:resources.Outputs.PdfValidationStateMachineArn.Value}
  checkForMalware:
    handler: ./src/lambda/checkForMalware.handler

stepFunctions:
  stateMachines:
    PdfValidationStateMachine:
      id: PdfValidationStateMachine
      definition:
        Comment: "PDF validation state machine"
        StartAt: CheckForMalware
        States:
          CheckForMalware:
            Type: Task
            Resource:
              Fn::GetAtt: [checkForMalware, Arn]
            End: true
        TimeoutSeconds: 300

